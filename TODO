* energy-saving?
   - get rid of it? it makes stuff much more complicated, not clear whether
     it actually saves something
   - if we do it, can also change PrivVal(..) etc -> but then we would need
     another PrivVal_safe() as well
   - do some benchmarking
* if not isinstance(nwcond,LinComb): nwcond = LinComb.ZERO+nwcond
  does that cost efficiency?
* dealing with huge values, e.g., compute 2^10000 gives segfault
  time python3 exp.py 2 10000
* TypeError instead of ValueError?
* while: only overwrite if really changed -> do in if_then_else?
* to prevent confusion, also use LinComb.ONE.value for __sub__, __add__, etc
  problem of secretsanta: cond that is yielded is maybe not a bit!
* remove gtest 
* solve double dependency thing?
    * libsnark ../xbyak, ../ate-pairing laten gebruiken? libqap met cmake?
        http://mingw-w64.org/doku.php/download
* does making a source distribution work?
* windows cross-compiling?
* benchmarking: @guarded_and_unguarded
   - multivariate regression as recursive linear regression, BenchmarkResult
     with __add__, __mul__, __sub__
* libsnark: automatically load key given by hash?
* energy saving branches
   - bits: use 0 (and other ValueError computations)
   - use guard as ONE
   - check for other computations
     (could be beneficial to have safe instead of unsafe, document this
     possibility: user can itself initially set stuff to zero)
* bounds
   - Var(bound=...) -> check and put bound in verification key file
   - verbose option: per computed variable, print computed bounds
     (__file__:__line: "x" has bound [0,20])
   - need to override base type (for bounds) and probably also backend?
* libsnark: split readinga and writing:
   - bool try_read(cs=NULL) -> read and check against cs if given, return true
     if still the same
   - void generate()
   - void write()
* secret santa:
   - amazon lambda, snarkjs
   - assert hashes unequal to each other
* put @snark in separate module
* make inhibit_profiling configurable
* multiple backends: use libsnark if no backend imported and if available, if
  need subqap then will import libqap
* do sudoku example
* rename / operator because it's too dangerous
* make ggh hashing more transparent: one function, conditonal % inside
* check where .value is used: can we avoid all use outside of runtime?

* jupyter, mybinder.org, https://aws.amazon.com/getting-started/projects/build-serverless-web-app-lambda-apigateway-s3-dynamodb-cognito/